# МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ  
## КИЇВСЬКИЙ ФАХОВИЙ КОЛЕДЖ ЗВ'ЯЗКУ  

---

# ЗВІТ  
## Про виконання лабораторної роботи №3  
### З дисципліни «Операційні системи»  
### На тему: «Знайомство з базовими командами CLI-режиму в Linux»

---

**Виконала:**  
студентка групи БІКС-33  
Руда Дарина Сергіївна  

**Перевірив викладач:**  
Сушанова Вікторія Сергіївна  

Київ 2026  

---

# Тема роботи  
**Знайомство з базовими командами CLI-режиму в Linux**

# Мета роботи  
- Ознайомлення з базовими командами CLI-режиму в Linux.  
- Вивчення текстових команд у термінальному режимі роботи в різних ОС.  
- Набуття практичних навичок роботи з оболонкою Bash.

---

# 1. Словник базових англійських термінів

| Термін | Визначення |
|--------|------------|
| Command Line Interface (CLI) | Текстовий інтерфейс керування ОС за допомогою команд |
| Shell | Оболонка — інтерпретатор команд |
| Bash | Bourne Again Shell — найпоширеніша оболонка Linux |
| Prompt | Рядок запрошення |
| Command | Команда |
| Option | Параметр команди |
| Argument | Аргумент команди |
| Alias | Псевдонім |
| Variable | Змінна |
| Environment Variable | Змінна середовища |
| Built-in command | Вбудована команда |
| External command | Зовнішня команда |
| Quoting | Використання лапок для керування інтерпретацією тексту |

---

# 2. Визначення понять

**Командний інтерпретатор** —  це програмне забезпечення, яке приймає введені користувачем команди, аналізує їх і передає операційній системі для виконання.


**Оболонка (Shell)** — це інтерфейс між користувачем і операційною системою, який дозволяє вводити команди, керувати файлами, процесами та виконувати сценарії.
.

**Команда** — це інструкція, введена в командному рядку, яка виконує певну дію в операційній системі (наприклад, перегляд файлів, створення каталогів, виведення інформації).


---

# 5. Відповіді на питання

## 1. Яку базову інформацію надає рядок запрошення (prompt)?

Рядок запрошення містить:
- ім’я користувача;
- назву системи (hostname);
- поточний робочий каталог;
- символ готовності до введення команди (`$` — звичайний користувач, `#` — root).

Наприклад, символ `~` означає домашній каталог користувача.

---

## 2. Для чого команді потрібні параметри та аргументи?

- **Параметри (options)** змінюють або розширюють поведінку команди.
- **Аргументи (arguments)** вказують, з якими об’єктами (файлами, каталогами, користувачами) команда повинна працювати.

---

## 3. Призначення команди `ls` та приклади використання

Команда `ls` використовується для перегляду вмісту каталогів. За замовчуванням вона відображає список файлів і підкаталогів у поточному робочому каталозі.

### Приклади використання:

```bash
ls
```
Показує файли та каталоги поточного каталогу.

```bash
ls -l
```
Виводить детальну інформацію про файли (права доступу, власника, групу, розмір і дату останньої зміни).

```bash
ls /etc
```
Показує вміст каталогу `/etc`.

---

## 4. Як можна використати історію команд і які її переваги?

Історія команд дозволяє переглядати та повторно використовувати раніше введені команди:

- за допомогою клавіш ↑ та ↓;
- за допомогою команди `history`;
- через повторний запуск команди `!номер`.

Переваги використання історії команд:
- економія часу;
- зменшення кількості помилок;
- підвищення продуктивності роботи в терміналі.

---

## 5. Яке призначення команди `echo`?

Команда `echo` використовується для виведення тексту або значень змінних у термінал.

### Приклад:

```bash
echo Hello Linux
```
## 6. Поняття змінної в оболонці Bash та її типи

Змінна — це іменоване сховище даних у пам’яті, яке використовується для збереження текстових або числових значень під час роботи оболонки.

У Bash існують такі типи змінних:

- **Локальні змінні** — діють тільки в межах поточної оболонки та не передаються іншим процесам.
- **Змінні середовища (environment variables)** — доступні всім дочірнім процесам і програмам, що запускаються з цієї оболонки.

---

## 7. Призначення команд `env`, `export` та `unset`

- `env` — показує список змінних середовища.
- `export` — робить змінну доступною для інших процесів (перетворює локальну змінну на змінну середовища).
- `unset` — видаляє змінну з поточної оболонки.

---

## 8. Команди для отримання довідки в терміналі

- `man команда` — відкриває детальну довідку (manual page) по команді.
- `help команда` — виводить довідку для вбудованих команд оболонки.
- `команда --help` — показує коротку інформацію про використання команди та її параметри.
# Лабораторна 5

| Назва команди | Призначення та функціональність |
|---------------|----------------------------------|
| `ls` | Виводить список файлів і каталогів у поточному каталозі. За замовчуванням показує лише імена. |
| `ls -l` | Виводить список файлів і каталогів у довгому форматі, включаючи права доступу, власника, групу, розмір і дату останньої зміни. |
| `ls -l /tmp` | Виводить детальну інформацію про файли та каталоги у каталозі `/tmp`. |
| `ls -l /home` | Виводить детальну інформацію про файли та каталоги у каталозі `/home`. |
| `whoami` | Показує ім’я поточного користувача. |
| `uname` | Показує назву операційної системи (kernel). |
| `uname -n` / `uname --nodename` | Показує hostname (ім’я вузла) комп’ютера. |
| `pwd` | Виводить повний шлях до поточного робочого каталогу. |
| `history` | Виводить список останніх виконаних команд. |
| `history <n>` | Виводить останні `<n>` команд з історії. |
| `!<номер>` | Виконує команду з історії під номером `<номер>`. |
| `echo <текст>` | Виводить вказаний текст на екран. |
| `echo $<змінна>` | Виводить значення змінної середовища (наприклад, `echo $PATH`). |
| `which <команда>` | Визначає шлях до виконуваного файлу команди, використовуючи змінну `$PATH`. |
| `type <команда>` | Показує тип команди: внутрішня (builtin), зовнішня (executable), alias або функція. |
| `type -a <команда>` | Виводить всі можливі місця знаходження команди, включаючи alias та виконувані файли. |
| `alias` | Показує або встановлює псевдоніми для команд. |
| `echo $(<команда>)` | Виконує команду в дужках та підставляє її результат у текст (command substitution). |
| ``echo `<команда>` `` | Старіший синтаксис command substitution (аналог `$()`). |
| `echo 'текст'` | Виводить текст без інтерпретації змінних та спеціальних символів. |
| `echo "текст"` | Виводить текст з інтерпретацією змінних і команд у backticks. |
| `echo \*` | Екранує спеціальні символи (наприклад, `*`). |
| `;` | Послідовне виконання кількох команд незалежно від результату попередньої. |
| `&&` | Виконує наступну команду лише якщо попередня виконалася успішно. |
| `\|\|` | Виконує наступну команду у разі помилки попередньої. |
| `true` | Завжди повертає успішний статус (0). |
| `false` | Завжди повертає статус помилки (не 0). |

---

# Лабораторна 6

| Назва команди | Призначення та функціональність |
|---------------|----------------------------------|
| `date` | Виводить поточну дату та час системи. |
| `man <команда>` | Відкриває сторінку керівництва (manual page) для команди. |
| `locate <ім'я_файлу>` | Швидко шукає файли за назвою, використовуючи базу даних. |
| `locate -b "\<ім'я_файлу>"` | Шукає файли з точним ім’ям без часткових збігів. |
| `whereis <команда>` | Показує розташування виконуваного файлу, man-сторінок і вихідного коду. |
| `whatis <команда>` | Виводить короткий опис команди. |
| `info <команда>` | Відкриває розширену info-сторінку команди. |
| `man -f <команда>` | Показує всі man-сторінки для команди та їхні секції. |
| `man -k <ключове_слово>` | Пошук у man-сторінках за ключовим словом. |
| `apropos <ключове_слово>` | Аналог `man -k`; пошук у описах man-сторінок. |
| `<команда> --help` | Виводить коротку довідку по команді та список її опцій. |
| Клавіші в `man/info` | `h` – допомога, `q` – вихід, `Space` – вниз на сторінку, `b` – вверх, `Enter` – вниз на рядок, `n/N` – наступне/попереднє входження. |
| `/текст` | Пошук слова вперед у man/info. |
| `?текст` | Пошук слова назад у man/info. |
## Виконання практичної частини лабораторної роботи

Виконання практичної частини лабораторної роботи розпочалося із запуску операційної системи сімейства GNU/Linux. Після завантаження системи я відкрила вікно емулятора термінала для доступу до командного інтерпретатора Bash.

Рядок запрошення (prompt) у форматі `liveuser@localhost-live:~$` підтвердив, що я працюю під обліковим записом звичайного користувача у домашній директорії (`~`). Перед початком виконання індивідуальних завдань я перевірила працездатність базових команд та ознайомилася з оточенням оболонки.

Всі подальші кроки виконувалися безпосередньо в активній сесії термінала, що підтверджено скріншотами.

---

## 2.1. Робота зі змінними (Variables) та псевдонімами (Aliases) в терміналі

У ході виконання завдання було створено змінні:

```bash
var_name1="Dasha"
var_name2="Ruda"
var_name3="Student"

echo $var_name1
echo $var_name2
echo $var_name3

```
Було створено псевдонім для команди:
```alias ll='ls -l'
ll
```
Перегляд списку псевдонімів:
```alias
```
Видалення псевдоніма:
```
unalias ll
```
**##2.1. Робота зі змінними (Variables) та псевдонімами (Aliases) в терміналі:**
<img width="544" height="212" alt="image" src="https://github.com/user-attachments/assets/a803f413-51fe-40af-b87a-6b8cf51b1df1" />
# Робота з локальними змінними в оболонці Bash

На даному етапі продемонстровано роботу з **локальними змінними** оболонки Bash. Процес складався з оголошення змінних та їх подальшого виводу в термінал.

## Виконані дії:

1.  **Створення змінних:**
    Було створено три змінні: `var_name1`, `var_name2` та `var_name3`.
    
2.  **Присвоєння значень:**
    Кожній змінній присвоєно текстове значення (прізвище та ім'я члена команди) за допомогою оператора `=`.
    > **Важливо:** Для коректного збереження імен з пробілами було використано **подвійні лапки**.

3.  **Виведення результату:**
    Після оголошення змінних було виконано команду `echo` з префіксом `$`. Це дозволило звернутися до вмісту змінних та вивести імена студентів у термінал.

---

### Приклад коду, що використовувався:
```bash
var_name1="Прізвище Ім'я1"
var_name2="Прізвище Ім'я2"
var_name3="Прізвище Ім'я3"

echo $var_name1
echo $var_name2
echo $var_name3
```
<img width="641" height="460" alt="image" src="https://github.com/user-attachments/assets/1e507d4e-1b62-4840-bce9-e6361d83cdaf" />
# Використання механізму псевдонімів (Aliases)

На даному етапі продемонстровано використання механізму **псевдонімів (Aliases)** для скорочення довгих або часто використовуваних команд у середовищі Bash.

## Опис процесу

1.  **Створення псевдонімів:**
    За допомогою команди `alias` було створено три нові команди, що відповідають рокам народження членів команди:
    * `mycal1` — виконує `cal 2005`
    * `mycal2` — виконує `cal 2006`
    * `mycal3` — виконує `cal 2007`

2.  **Призначення:**
    Ці псевдоніми дозволяють автоматично викликати команду `cal` з аргументами відповідних років без необхідності щоразу вводити повну команду.

3.  **Перевірка працездатності:**
    Після оголошення було здійснено перевірку шляхом введення команди `mycal1`. Це призвело до коректного виведення повного календаря на **2005 рік** безпосередньо у терміналі.

---

### Використані команди:
```bash
alias mycal1='cal 2005'
alias mycal2='cal 2006'
alias mycal3='cal 2007'

# Перевірка
mycal1
```
<img width="694" height="460" alt="image" src="https://github.com/user-attachments/assets/0cb27cff-58fc-4ec9-924a-018fa0dbbcee" />
<img width="772" height="507" alt="image" src="https://github.com/user-attachments/assets/ef8a0f65-49b5-4243-8757-727ef7449eed" />
## Створення та перевірка користувацьких псевдонімів

На скріншотах продемонстровано процес створення користувацьких команд (**псевдонімів**) за допомогою команди `alias`. 

### Основні кроки:
* **Налаштування:** Для кожного члена команди було створено окремий псевдонім: `mycal1`, `mycal2` та `mycal3`.
* **Автоматизація:** Ці команди автоматично запускають системну утиліту `cal` для конкретних років народження:
    * `mycal1` — 2005 рік;
    * `mycal2` — 2006 рік;
    * `mycal3` — 2007 рік.
* **Результат:** Використання таких скорочень дозволяє швидко отримувати потрібні дані без повторного введення повних параметрів команди.

---

### Приклад конфігурації:
```bash
alias mycal1='cal 2005'
alias mycal2='cal 2006'
alias mycal3='cal 2007'
```
##**2.2. *Робота з функціями (Functions) в терміналі:
**<img width="616" height="282" alt="image" src="https://github.com/user-attachments/assets/0c1d27ec-ac41-4f60-ab44-0998b9e9a09a" />
## Оголошення та виконання користувацької функції `students_report()`

На скріншоті продемонстровано процес створення комплексної користувацької функції, яка об'єднує попередні напрацювання (змінні та псевдоніми) в один сценарій.

### Технічні деталі:
* **Структура функції:** Тіло функції `students_report()` містить послідовність команд для:
    * Виведення вмісту раніше створених змінних за допомогою `echo $var_name1`, `echo $var_name2` та `echo $var_name3`.
    * Запуску псевдонімів `mycal1`, `mycal2`, `mycal3` для автоматичного відображення календарів.
* **Інтерфейс оболонки:** Символ замовлення `>` на скріншоті вказує на те, що оболонка Bash перебуває в режимі очікування завершення блоку команд у фігурних дужках `{ ... }`. Це підтверджує коректне багаторядкове введення структури функції.

---

### Код функції:
```bash
students_report() {
    echo $var_name1
    echo $var_name2
    echo $var_name3
    mycal1
    mycal2
    mycal3
}
```
<img width="763" height="577" alt="image" src="https://github.com/user-attachments/assets/a5a4a9ae-54f3-4902-8511-bd36d988ca45" />
 Після завершення опису функції її було викликано в терміналі шляхом введення назви students_report.
 <img width="784" height="583" alt="image" src="https://github.com/user-attachments/assets/bbccfc5e-47ad-4256-9243-fc94b92a7df0" />
<img width="784" height="574" alt="image" src="https://github.com/user-attachments/assets/22233c21-70d1-442d-be2c-8d97c0032335" />
<img width="827" height="562" alt="image" src="https://github.com/user-attachments/assets/86b5920d-fb8f-4fac-a34f-60d359b86d73" />
## Результати виконання функції `students_report()`

Як видно на скріншоті, функція успішно виконала всі вкладені команди в заданій послідовності, що демонструє злагоджену роботу локальних змінних та псевдонімів всередині одного сценарію.

### Аналіз виводу:
* **Перший етап:** У терміналі було послідовно виведено імена членів команди, збережені у змінних:
    1. `Dasha Ruda`
    2. `Milana Bagativna`
    3. `Olesia Klas`
* **Другий етап:** Було автоматично викликано псевдоніми, зокрема відображено повний календар для першого студента за **2005 рік**.

### Висновок:
Цей етап підтверджує гнучкість середовища Linux та можливість **автоматизації складних послідовностей дій** за допомогою функцій. Це дозволяє мінімізувати ручне введення та стандартизувати вивід даних.

---

### Команда для запуску:
```bash
# Виклик функції
students_report
```
##**2.3. *Робота з лапками (Quoting) в терміналі. 
**
<img width="790" height="580" alt="image" src="https://github.com/user-attachments/assets/0d0ceb43-8a10-4661-a7db-8c4f514064c8" />
## Екранування символів та інтерпретація змінних

На скріншоті продемонстровано використання зворотного слешу (`\`) для **екранування** спеціальних символів, що дозволяє керувати тим, як оболонка Bash обробляє текст.

### Ключові моменти:
* **Екранування (`\$`):** Використання зворотного слешу перед символом долара дозволило вивести назви змінних як звичайний текст (`$var_name1`, `$var_name2`, `$var_name3`), ігноруючи їхню функцію звернення до значення.
* **Інтерпретація:** Водночас у тому ж реченні змінні було вказано без екранування. Це дозволило Bash інтерпретувати їх та підставити реальні дані — імена студентів (наприклад, `Dasha Ruda`).

### Приклад використаної логіки:
```bash
echo "Значення змінної \$var_name1 це $var_name1"
# Результат: Значення змінної $var_name1 це Dasha Ruda
```
<img width="751" height="551" alt="image" src="https://github.com/user-attachments/assets/b3aa55fc-6344-42f9-83f2-1c39b0dbea41" />
## Формування складних повідомлень та виконання псевдонімів

На даному етапі продемонстровано поєднання інформаційного виводу з роботою користувацьких команд.

### Опис результату:
* **Текстовий блок:** Сформовано та виведено складне текстове повідомлення, що описує призначення псевдонімів `mycal1`, `mycal2` та `mycal3`. Це дозволяє користувачеві зрозуміти контекст перед виконанням команди.
* **Виконання команди:** Одразу після виведення інформації було виконано команду-псевдонім `mycal1`.
* **Візуалізація:** Результатом стало відображення повного календаря на **2005 рік** безпосередньо під текстом у терміналі, що підтверджує успішну інтеграцію описів та функціоналу.

---

### Приклад послідовності дій:
```bash
echo "Виконуємо команду mycal1 для перевірки календаря:"
mycal1
```
<img width="740" height="545" alt="image" src="https://github.com/user-attachments/assets/4175eab4-36c1-4c2e-a591-2f5f2626e117" />
Цей етап підтвердив розуміння різниці між інтерпретованим та неінтерпретованим виводом у Bash, що є критично важливим для роботи зі сценаріями.

##**2.4. **Робота з інструкціями керування (Control Statements) в терміналі:.
**
<img width="764" height="554" alt="image" src="https://github.com/user-attachments/assets/076f16fe-603f-497b-ac1b-3f3d02c0f4ef" />

## Дослідження циклів та робота з документацією

У даному розділі було досліджено можливість оптимізації завдань з виводу даних за допомогою циклів, а також роботу з довідковою системою Linux.

### Використання циклів `for` для автоматизації

Замість ручного виклику кожної змінної було продемонстровано переваги інструкцій керування:

1.  **Перебір імен:** Використано цикл `for name in $var_name1 $var_name2 $var_name3; do echo $name; done`. Цикл послідовно звертається до кожної змінної та виводить її вміст. Це підтверджує, що для роботи зі списками значень цикли є більш лаконічним інструментом, ніж створення окремих функцій чи ручне введення.
    
2.  **Перебір числових значень:** Аналогічно реалізовано цикл для виведення років народження (`2007 2006 2005`). Це дозволило отримати структурований список значень у стовпчик за допомогою єдиної конструкції:
    ```bash
    for year in 2007 2006 2005; do echo $year; done
    ```

> **Примітка щодо помилок:** На скріншоті зафіксовано початкову спробу використання неіснуючої змінної `$var`. Процес було вчасно перервано комбінацією клавіш **Ctrl+C** (`^C`), після чого введено коректний синтаксис.

---

### 2.5. Робота з командами довідки (Man Pages)

Для детального вивчення інструментів системи було використано вбудовану документацію. Команда `man uname` відкрила посібник користувача, де міститься опис утиліти, призначеної для виведення системної інформації (назва ядра, версія ОС, архітектура процесора тощо).
<img width="750" height="547" alt="image" src="https://github.com/user-attachments/assets/ab13a10f-6c85-47ff-a1ed-f71953ddab8d" />
Після цього натиснувши на q: <img width="759" height="557" alt="image" src="https://github.com/user-attachments/assets/f778ca39-a7f4-4735-ad57-7c52fb88b1f0" />
## Робота з системною документацією та утилітою `uname`

Для вивчення функціоналу команди `uname` було використано вбудовану довідкову систему Linux за допомогою команди `man uname`. 

### Огляд інтерфейсу Man Pages
На скріншоті видно стандартний інтерфейс довідника, який містить:
* **NAME:** Назва та короткий опис команди.
* **SYNOPSIS:** Синтаксис використання.
* **DESCRIPTION:** Детальний опис доступних параметрів (Options), таких як `-a`, `-s`, `-n`, `-r`.

### Тестування параметрів команди `uname`
На основі отриманої довідки було протестовано 5 варіантів виводу системної інформації:

| Команда | Опис результату |
|:---|:---|
| `uname -a` | Вивід усієї системної інформації (тип ОС, ім'я хоста, версія ядра, архітектура). |
| `uname -s` | Вивід лише назви ядра операційної системи (**Linux**). |
| `uname -r` | Відображення поточної версії випуску ядра. |
| `uname -v` | Детальна інформація про версію та дату збірки ядра. |
| `uname -m` | Вивід назви апаратної архітектури машини (**x86_64**). |

---

### Аналіз помилок при роботі з терміналом
На скріншоті також зафіксовано технічний нюанс: появу помилки `bash: q: command not found`. 

> **Причина:** Користувач намагався вийти з режиму перегляду довідки, проте клавіша **q** була натиснута вже після того, як довідник був закритий. Оскільки в командному рядку Bash немає окремої команди `q`, система видала відповідне попередження.
## Контрольні запитання та відповіді

### 1. Які типи команд існують в оболонці Bash?
В оболонці Bash існує кілька основних типів команд:
* **Вбудовані (built-in):** Команди, що інтегровані безпосередньо в оболонку (наприклад: `cd`, `echo`, `export`, `history`).
* **Зовнішні команди:** Окремі виконувані файли, що зберігаються у файловій системі (наприклад: `ls`, `cp`, `mv`).
* **Аліаси (aliases):** Користувацькі скорочення для довгих команд.
* **Функції:** Набори команд, об’єднані під одним іменем для багаторазового використання.

### 2. Що таке змінні оточення та як їх переглянути?
**Змінні оточення** — це змінні, що зберігають конфігураційні дані системи, доступні для оболонки та її дочірніх процесів.
* **Локальні змінні:** діють лише в межах поточного сеансу оболонки.
* **Змінні оточення (environment variables):** передаються запущеним програмам.

**Команди для перегляду:**
* `env` — перегляд змінних оточення.
* `printenv` — вивід конкретних або всіх змінних середовища.
* `set` — вивід усіх змінних (і локальних, і оточення).

### 3. Опишіть змінну `$PS1`. Як переглянути її вміст?
Змінна `$PS1` визначає структуру та зовнішній вигляд основного рядка запрошення (prompt) у терміналі (ім'я користувача, хост, шлях).
* **Перегляд:** `echo $PS1`

### 4. Як змінити значення `$PS1` тимчасово та назавжди?
* **Тимчасово:** Ввести в терміналі `PS1=">>> "`.
* **Постійно:** Додати рядок з визначенням змінної у конфігураційні файли `~/.bashrc` або `~/.bash_profile`.

### 5. Для чого використовують лапки в Bash?
Лапки керують інтерпретацією спецсимволів:
* **Подвійні (`" "`)**: Дозволяють підстановку змінних (`$`) та виконання команд.
* **Одинарні (`' '`)**: Сприймають увесь текст як літеральний (забороняють будь-яку обробку).
* **Зворотні (`` ` ``)**: Використовуються для підстановки результату виконання команди.

### 6. Для чого використовують інструкції керування?
Вони дозволяють будувати логічні ланцюжки команд:
* `;` — послідовне виконання.
* `&&` — виконання наступної команди лише при успіху попередньої.
* `||` — виконання лише у разі помилки попередньої.
* `|` — конвеєр (передача виводу однієї команди на вхід іншої).

### 7. Різниця між символами `$` та `#` у запиті?
* `$` — звичайний користувач.
* `#` — суперкористувач (root).

### 8. Призначення `whereis` та `locate`?
* `whereis`: Шукає бінарні файли, джерела та документацію конкретної команди.
* `locate`: Швидкий пошук будь-якого файлу в системі за іменем через заздалегідь проіндексовану базу даних.

---

## ВИСНОВОК / CONCLUSION

During this laboratory work, I have mastered the fundamental principles of the Command Line Interface (CLI) and the Bash shell. I studied the standard syntax of Linux commands, which consists of the command name, options, and arguments, where options modify behavior and arguments provide specific data for processing. In practice, this was implemented by using the `ls` command with various flags to view directory contents.

I acquired essential practical skills for managing the user environment: I learned how to create variables for temporary data storage and aliases to create short nicknames for long command sequences. Specifically, I automated the display of calendars using aliases for the `cal` command. Furthermore, I mastered the use of functions, which allow grouping a sequence of actions into a single new command, as demonstrated by creating the `students_report` script.

A critical part of the work involved studying quoting and escaping mechanisms. I learned to distinguish between different types of quotes to control how the Bash shell interprets special characters. I also explored the use of control statements, particularly `for` loops, which allow for the automation of repetitive operations on data lists without the need for predefined functions. Finally, I learned to effectively use the **Man Pages** system to independently study the functionality of new commands, demonstrated through the `uname` utility.

Overall, the work confirmed that CLI proficiency provides more precise control over the system, greater operational speed, and the ability to automate tasks through scripting.



















